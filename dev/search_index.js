var documenterSearchIndex = {"docs":
[{"location":"#Methode*of*conjugate_gradients.jl","page":"Methodeofconjugate_gradients.jl","title":"Methodeofconjugate_gradients.jl","text":"","category":"section"},{"location":"","page":"Methodeofconjugate_gradients.jl","title":"Methodeofconjugate_gradients.jl","text":"This is the documentation for the repository of the method of Conjugate Gradients.jl. The documentation is divided into two parts. The first part provides a mathematical explanation of Conjugate Gradients and Gradient Descent. The second part provides a detailed explanation of the code.","category":"page"},{"location":"#The-mathematical-explanation","page":"Methodeofconjugate_gradients.jl","title":"The mathematical explanation","text":"","category":"section"},{"location":"","page":"Methodeofconjugate_gradients.jl","title":"Methodeofconjugate_gradients.jl","text":"Here will 1","category":"page"},{"location":"#Conjugate-gradient-method","page":"Methodeofconjugate_gradients.jl","title":"Conjugate gradient method","text":"","category":"section"},{"location":"#The-Gradient-descent-method","page":"Methodeofconjugate_gradients.jl","title":"The Gradient descent method","text":"","category":"section"},{"location":"#The-code-explaind","page":"Methodeofconjugate_gradients.jl","title":"The code explaind","text":"","category":"section"},{"location":"","page":"Methodeofconjugate_gradients.jl","title":"Methodeofconjugate_gradients.jl","text":"This code imports three Julia packages: LinearAlgebra, Plots, and PlotlyJS.","category":"page"},{"location":"","page":"Methodeofconjugate_gradients.jl","title":"Methodeofconjugate_gradients.jl","text":"    using LinearAlgebra\n    using Plots\n    using PlotlyJS","category":"page"},{"location":"","page":"Methodeofconjugate_gradients.jl","title":"Methodeofconjugate_gradients.jl","text":"The code defines a ScatteredArray structure with two matrices and provides custom multiplication and size functions for it.\n```julia\n struct ScatteredArray\n     V::Matrix{Float64}\n     I::Matrix{Int}\n end\n\n # Multiplication function for ScatteredArray\n function Base.:*(A::ScatteredArray, x::Vector{Float64})\n     result = zeros(size(A.I, 1))\n\n     for row in 1:size(A.I, 1)\n         for col in 1:size(A.I, 2)\n             i = A.I[row, col]\n             if i != 0 && i <= length(x)\n                 result[row] += A.V[row, col] * x[i]\n             end\n         end\n     end\n\n     return result\n end\n\n # Get the size of ScatteredArray\n Base.size(A::ScatteredArray, dim::Integer) = size(A.I, dim)\n```\nThis code defines a conj_grad function that solves a linear system Ax = b using the conjugate gradient method, given a ScatteredArray A and Vector b. It returns the solution, number of iterations, and residuals.\n```julia      function conjgrad(A::ScatteredArray, b::Vector{Float64}; x0=nothing, tol=1e-6, maxiter=1000)          if x0 === nothing              x = zeros(Float64, size(A, 1))          else              x = x0          end\n     r = b - A * x\n     p = copy(r)\n     rsold = dot(r, r)\n\n     residuals = Float64[]  # Added this line to initialize an array for residuals\n\n     for i in 1:max_iter\n         Ap = A * p\n         alpha = rsold / dot(p, Ap)\n         x = x + alpha * p\n         r = r - alpha * Ap\n\n         rsnew = dot(r, r)\n         push!(residuals, sqrt(rsnew))  # Added this line to store the residuals\n\n         if sqrt(rsnew) < tol\n             break\n         end\n\n         p = r + (rsnew / rsold) * p\n         rsold = rsnew\n     end\n\n     return x, i, residuals  # Added 'residuals' to the return values\n end\n```\nThis code provides two optimization functions, gradient descent and conjugate gradient, for a 2D quadratic function.","category":"page"},{"location":"","page":"Methodeofconjugate_gradients.jl","title":"Methodeofconjugate_gradients.jl","text":"gradientdescent and conjgrad_2d take a starting point, maximum number of iterations, tolerance, and learning rate/small value for epsilon as arguments. They return the optimized x value and the path taken during optimization as a list.","category":"page"},{"location":"","page":"Methodeofconjugate_gradients.jl","title":"Methodeofconjugate_gradients.jl","text":"\n    A = [4 1; 1 3]\n    b = [-1; -1]\n\n    function f(x)\n        return 0.5 * x' * A * x - b' * x\n    end\n\n    function grad_f(x)\n        return A * x - b\n    end\n\n    function gradient_descent(grad_f, x0, max_iter=1000, tol=1e-6, lr=0.1)\n        x = x0\n        path = [x0]\n\n        for i in 1:max_iter\n            g = grad_f(x)\n            x = x - lr * g\n            push!(path, x)\n\n            if norm(grad_f(x)) < tol\n                break\n            end\n        end\n\n        return x, path\n    end\n\n    function conj_grad_2d(A, b, x0, max_iter=1000, tol=1e-6)\n        x = x0\n        r = b - A * x\n        p = copy(r)\n\n        path = [x0]\n\n        for i in 1:max_iter\n            alpha = dot(r, r) / dot(p, A * p)\n            x = x + alpha * p\n            push!(path, x)\n\n            r_new = r - alpha * A * p\n\n            if norm(r_new) < tol\n                break\n            end\n\n            beta = dot(r_new, r_new) / dot(r, r)\n            p = r_new + beta * p\n            r = r_new\n        end\n\n        return x, path\n    end\n","category":"page"}]
}
